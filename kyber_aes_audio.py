# -*- coding: utf-8 -*-
"""Kyber_AES_Audio.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uZC5lK7awUWl2qNgYNSEq2kH_2bHDvq-
"""

!pip install pycryptodome

!git clone https://github.com/giacomopope/kyber-py.git

# Commented out IPython magic to ensure Python compatibility.
# %cd kyber-py
!pip install -r requirements.txt

from kyber import Kyber512

from kyber import Kyber512
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
import wave
import pickle

# Function to read audio file and return its byte data
def read_audio(file_path):
    with wave.open(file_path, 'rb') as wf:
        return wf.readframes(wf.getnframes()), wf.getparams()

# Function to write binary data to a file
def write_file(file_path, data):
    with open(file_path, 'wb') as f:
        f.write(data)

# Function to encrypt audio data
def encrypt_audio(audio_data, key):
    cipher = AES.new(key, AES.MODE_GCM)
    ciphertext, tag = cipher.encrypt_and_digest(audio_data)
    return cipher.nonce, tag, ciphertext

# Paths to your input and output files
audio_path = '/content/sample.wav'  # Update with your audio file path
encrypted_audio_path = 'encrypted_audio.bin'

# Kyber key generation
pk, sk = Kyber512.keygen()

# Encapsulate the AES key using Kyber
c, aes_key = Kyber512.enc(pk)

# Save the ciphertext and Kyber secret key to files
with open('ciphertext.bin', 'wb') as f:
    f.write(c)

with open('secret_key.bin', 'wb') as f:
    f.write(sk)

# Read the original audio data
original_audio_data, audio_params = read_audio(audio_path)

# Encrypt the audio
nonce, tag, encrypted_data = encrypt_audio(original_audio_data, aes_key)
write_file(encrypted_audio_path, nonce + tag + encrypted_data)

# Serialize and save the audio parameters
with open('audio_params.bin', 'wb') as f:
    pickle.dump(audio_params, f)

print("Audio encrypted and AES key encapsulated using Kyber. Data saved to files.")

from kyber import Kyber512
from Crypto.Cipher import AES
import wave
import pickle

# Function to read binary data from a file
def read_file(file_path):
    with open(file_path, 'rb') as f:
        return f.read()

# Function to write audio data to a file
def write_audio(file_path, audio_data, params):
    with wave.open(file_path, 'wb') as wf:
        wf.setparams(params)
        wf.writeframes(audio_data)

# Function to decrypt audio data
def decrypt_audio(nonce, tag, ciphertext, key):
    cipher = AES.new(key, AES.MODE_GCM, nonce=nonce)
    decrypted_data = cipher.decrypt_and_verify(ciphertext, tag)
    return decrypted_data

# Paths to your input and output files
encrypted_audio_path = 'encrypted_audio.bin'
decrypted_audio_path = 'decrypted_audio.wav'

# Load the Kyber secret key
sk = read_file('secret_key.bin')

# Load the ciphertext
c = read_file('ciphertext.bin')

# Decapsulate the AES key using Kyber
aes_key = Kyber512.dec(c, sk)

# Read the encrypted data from the file
with open(encrypted_audio_path, 'rb') as f:
    nonce = f.read(16)
    tag = f.read(16)
    ciphertext = f.read()

# Deserialize the audio parameters
with open('audio_params.bin', 'rb') as f:
    audio_params = pickle.load(f)

# Decrypt the audio
decrypted_audio_data = decrypt_audio(nonce, tag, ciphertext, aes_key)
write_audio(decrypted_audio_path, decrypted_audio_data, audio_params)

print("Audio decrypted and saved to", decrypted_audio_path)